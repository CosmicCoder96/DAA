<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>In-Place Merge Sort</title>
</head>

<body>
<h2 align="center"><a name="Top"></a>In-Place Merge Sort <a href="#Footnote">*</a></h2>
<p>If you want to avoid the space complexity required by having a scratch array,
you <i>can</i> use the merge sort algorithm, but then move the data around
within the original array.&nbsp; This version supports the recursive formulation,
and the only change is in the merge logic.</p>
<p><tt>private static void inPlaceSort ( Comparable[] x, int first, int last )</tt></p>
<p>The recursive base case, as usual, is the array of length one (or
zero):&nbsp; <tt>first&gt;=last</tt>.
</p>
<p>Otherwise, compute a mid-point (<tt>mid=(first+last)/2;</tt>), and then
recursively sort the data from <tt>first</tt> up through&nbsp; <tt>mid</tt>, and
from <tt>mid+1</tt> up through <tt>last</tt>.</p>
<p align="center"><tt>inPlaceSort (x, first,&nbsp; mid);<br>
inPlaceSort (x, mid+1, last);</tt></p>

<p align="left">The slightly tricky part is the merge logic.&nbsp; As usual, you
have a subscript into the left array segment (<tt>x[left]</tt>)
and the right array segment (<tt>x[right]</tt>).&nbsp; If&nbsp;<tt>x[left]</tt> tests as less than or equal to <tt>x[right]</tt>,
then it is already in place within the sorted array segment, so just increment <tt>
left</tt>.&nbsp; Otherwise, the array element in&nbsp;<tt>x[right]</tt> needs to move down into the
space currently occupied by <tt>x[left]</tt>, and to accommodate this, the entire
array segment from <tt>x[left]</tt> through <tt>x[right-1]</tt> needs to move up by one
— effectively you need to rotate that little segment of the array.&nbsp; In
the process, everything moves up by one, including the end of the left segment (<tt>mid</tt>).</p>
<tt><pre>      left = first;  right = mid+1;
      // One extra check:  can we SKIP the merge?
      if ( x[mid].compareTo(x[right]) &lt;= 0 )
         return;

      while (left &lt;= mid &amp;&amp; right &lt;= last)
      {  // Select from left:  no change, just advance left
         if ( x[left].compareTo(x[right]) &lt;= 0 )
            left++;
         // Select from right:  rotate [left..right] and correct
         else
         {  tmp = x[right];     // Will move to [left]
            System.arraycopy(x, left, x, left+1, right-left);
            x[left] = tmp;
            // EVERYTHING has moved up by one
            left++;  mid++;  right++;
         }
      }
      // Whatever remains in [right..last] is in place</pre></tt>
<p><u><b>Complexity analysis:</b></u></p>
<p>The recursive structure remains the same, so that
you have the lg(n) recursive levels in the processing, but the data movement is
markedly different.&nbsp; In the scratch-array implementation, the data movement
generated by the merge is O(n) — for the recursive formulation, straight
copy to generate the subarrays, followed by O(n) merging those sorted data back
into the parameter array; for the iterative formulation, a pure O(n) merging
data back and forth between the two arrays.</p>
<p>This case, though, has markedly different best- and worst-case situations.&nbsp;
The code explicitly notes the very best case (if the end of the left half is in
position with respect to the beginning of the right half, return), but even just
<i>shy</i> of the best case (say, one item out of position), the data movement
will still be O(1).&nbsp; That means that the complexity will be O(n).&nbsp; For
lg(n) levels, we have 1+2+4+8+&nbsp;.&nbsp;.&nbsp;. (i.e., the number of method invocations
at each level of the recursive execution tree).</p>
<p>In the worst case, however, within each execution the entire right side needs
to be moved to the left side — require O(n<sup>2</sup>) data movements (thanks
to the well-known series "1+2+3+4+5+...").&nbsp; Even in the average case, one can
expect half the time to need to move from the right side, again giving O(n<sup>2</sup>)
data movements.</p>
<p>The observed time behavior of the in-place merge sort is significantly faster
than the classical O(n<sup>2</sup>) algorithms (Selection Sort and Insertion
Sort), but still (for random and reversed data) can be extremely well fit by a
quadratic trend line within Excel.</p>
<p><b>Bottom line:&nbsp; memory is cheap, use the scratch array!</b></p>
<hr>
<p><big><big><a name="Footnote">*</a></big></big>&nbsp;The Java method discussed here is contained 
within the file <a href="http://penguin.ewu.edu/cscd300/Topic/AdvSorting/MergeSorts/MergeSort.java">MergeSort.java</a>.&nbsp; It builds on the 
structure of the algorithm in
<a href="http://www.cs.ubc.ca/%7Eharrison/Java/MergeSortAlgorithm.java.html">http://www.cs.ubc.ca/~harrison/Java/MergeSortAlgorithm.java.html</a></p>
<p><big><a href="#Top">Return to the top</a>.</big></p>


<div id="zenmate-widget" style="display: none;"><div id="message" class="plain">
  <div id="plain-widget">
    <img class="logo" src="In-Place%20Merge%20Sort_files/zenmateLogoBlack.png" srcset="resource://firefox-at-zenmate-dot-com/data/images/zenmateLogoBlack@2x.png 2x">
    <hr>
    <h1 id="headline">You're using ZenMate Free.</h1>
    <div id="description">Buy ZenMate Premium for only €6.49 with turbo speed for HD quality streaming!</div>
    <button id="submit-btn" data-url="">Upgrade to Premium</button>
  </div>

  <iframe id="iframe-widget" allowfullscreen="" src="" width="300" height="250" frameborder="0"></iframe>

  <button id="dismiss-btn">Remind me later</button>
</div>

<div title="You're protected by ZenMate" id="toggle-btn" class="active"></div>
</div></body></html>